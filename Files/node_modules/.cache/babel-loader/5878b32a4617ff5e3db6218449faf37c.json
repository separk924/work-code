{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getWin } from \"../util\";\nfunction toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n\n      // Placement\n      var placementInfo = builtinPlacements[placement] || popupAlign || {};\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height;\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n\n      // Get bounding of visible area\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ?\n      // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      (scrollerList || []).forEach(function (ele) {\n        var eleRect = ele.getBoundingClientRect();\n        var eleOutHeight = ele.offsetHeight,\n          eleInnerHeight = ele.clientHeight,\n          eleOutWidth = ele.offsetWidth,\n          eleInnerWidth = ele.clientWidth;\n        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n        var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n        var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n        var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n        var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n        visibleArea.left = Math.max(visibleArea.left, eleRect.left);\n        visibleArea.top = Math.max(visibleArea.top, eleRect.top);\n        visibleArea.right = Math.min(visibleArea.right, eleRight);\n        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n      });\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _ref = offset || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n        _ref2$2 = _ref2[1],\n        popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n      var _ref3 = targetOffset || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[0],\n        targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n        _ref4$2 = _ref4[1],\n        targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY;\n\n      // Points\n      var _ref5 = placementInfo.points || [],\n        _ref6 = _slicedToArray(_ref5, 2),\n        popupPoint = _ref6[0],\n        targetPoint = _ref6[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ================ Overflow =================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // >>>>>>>>>> Top & Bottom\n      var nextPopupY = popupRect.y + nextOffsetY;\n      var nextPopupBottom = nextPopupY + popupHeight;\n      var needAdjustY = supportAdjust(adjustY);\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && nextPopupBottom > visibleArea.bottom) {\n        nextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && nextPopupY < visibleArea.top) {\n        nextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n      }\n\n      // >>>>>>>>>> Left & Right\n      var nextPopupX = popupRect.x + nextOffsetX;\n      var nextPopupRight = nextPopupX + popupWidth;\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && nextPopupRight > visibleArea.right) {\n        nextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && nextPopupX < visibleArea.left) {\n        nextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n      }\n\n      // >>>>> Shift\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n          if (targetRect.x + targetRect.width < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetRect.width - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n          if (targetRect.y + targetRect.height < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetRect.height - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetRect.width;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetRect.height;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"names":["_objectSpread","_slicedToArray","useEvent","useLayoutEffect","React","collectScroller","getWin","toNum","num","Number","isNaN","splitPoints","points","arguments","length","undefined","getAlignPoint","rect","topBottom","leftRight","x","y","height","width","reversePoints","index","reverseMap","t","b","l","r","map","point","i","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","_React$useState","useState","ready","offsetX","offsetY","arrowX","arrowY","scaleX","scaleY","align","_React$useState2","offsetInfo","setOffsetInfo","alignCountRef","useRef","scrollerList","useMemo","onAlign","popupElement","originLeft","style","left","originTop","top","doc","ownerDocument","win","placementInfo","targetRect","Array","isArray","getBoundingClientRect","popupRect","_win$getComputedStyle","getComputedStyle","_doc$documentElement","documentElement","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","popupHeight","popupWidth","visibleArea","htmlRegion","right","bottom","forEach","ele","eleRect","eleOutHeight","offsetHeight","eleInnerHeight","eleOutWidth","offsetWidth","eleInnerWidth","Math","round","eleScrollWidth","eleScrollHeight","eleRight","eleBottom","max","min","_scaleX","parseFloat","_scaleY","offset","targetOffset","_ref","_ref2","_ref2$","popupOffsetX","_ref2$2","popupOffsetY","_ref3","_ref4","_ref4$","targetOffsetX","_ref4$2","targetOffsetY","_ref5","_ref6","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","nextOffsetX","nextOffsetY","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","overflow","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","nextPopupY","nextPopupBottom","needAdjustY","nextPopupX","nextPopupRight","needAdjustX","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","triggerAlign","current","id","Promise","resolve","then","resetReady","ori"],"sources":["/Users/seung/Documents/work-code/Files/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getWin } from \"../util\";\nfunction toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n\n      // Placement\n      var placementInfo = builtinPlacements[placement] || popupAlign || {};\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height;\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n\n      // Get bounding of visible area\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ?\n      // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      (scrollerList || []).forEach(function (ele) {\n        var eleRect = ele.getBoundingClientRect();\n        var eleOutHeight = ele.offsetHeight,\n          eleInnerHeight = ele.clientHeight,\n          eleOutWidth = ele.offsetWidth,\n          eleInnerWidth = ele.clientWidth;\n        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n        var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n        var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n        var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n        var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n        visibleArea.left = Math.max(visibleArea.left, eleRect.left);\n        visibleArea.top = Math.max(visibleArea.top, eleRect.top);\n        visibleArea.right = Math.min(visibleArea.right, eleRight);\n        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n      });\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _ref = offset || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n        _ref2$2 = _ref2[1],\n        popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n      var _ref3 = targetOffset || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[0],\n        targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n        _ref4$2 = _ref4[1],\n        targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY;\n\n      // Points\n      var _ref5 = placementInfo.points || [],\n        _ref6 = _slicedToArray(_ref5, 2),\n        popupPoint = _ref6[0],\n        targetPoint = _ref6[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ================ Overflow =================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // >>>>>>>>>> Top & Bottom\n      var nextPopupY = popupRect.y + nextOffsetY;\n      var nextPopupBottom = nextPopupY + popupHeight;\n      var needAdjustY = supportAdjust(adjustY);\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && nextPopupBottom > visibleArea.bottom) {\n        nextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && nextPopupY < visibleArea.top) {\n        nextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n      }\n\n      // >>>>>>>>>> Left & Right\n      var nextPopupX = popupRect.x + nextOffsetX;\n      var nextPopupRight = nextPopupX + popupWidth;\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && nextPopupRight > visibleArea.right) {\n        nextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && nextPopupX < visibleArea.left) {\n        nextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n      }\n\n      // >>>>> Shift\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n          if (targetRect.x + targetRect.width < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetRect.width - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n          if (targetRect.y + targetRect.height < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetRect.height - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetRect.width;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetRect.height;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}