{"ast":null,"code":"import { useMemo as $cAn5f$useMemo, useRef as $cAn5f$useRef, useEffect as $cAn5f$useEffect } from \"react\";\nimport { useMultipleSelectionState as $cAn5f$useMultipleSelectionState, SelectionManager as $cAn5f$SelectionManager } from \"@react-stately/selection\";\nimport $cAn5f$swchelperssrc_define_propertymjs from \"@swc/helpers/src/_define_property.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = (0, $cAn5f$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $cAn5f$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === \"cell\" && key != null) {\n      let item = collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n        var _children_, _children_1;\n        let children = [...item.childNodes];\n        if (child === \"last\") key = (_children_ = children[children.length - 1]) === null || _children_ === void 0 ? void 0 : _children_.key;else key = (_children_1 = children[0]) === null || _children_1 === void 0 ? void 0 : _children_1.key;\n      }\n    }\n    setFocusedKey(key, child);\n  };\n  let selectionManager = (0, $cAn5f$useMemo)(() => new (0, $cAn5f$SelectionManager)(collection, selectionState), [collection, selectionState]);\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = (0, $cAn5f$useRef)(null);\n  (0, $cAn5f$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n      let newRow;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key)) {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) index++;else {\n          if (index > parentNode.index) index = parentNode.index;\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...newRow.childNodes] : [];\n        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else selectionState.setFocusedKey(null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: selectionManager\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nlet $16805b1b18093c5f$var$_Symbol_iterator = Symbol.iterator;\nclass $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[$16805b1b18093c5f$var$_Symbol_iterator]() {\n    yield* [...this.rows];\n  }\n  get size() {\n    return [...this.rows].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var _;\n    return (_ = [...this.rows][0]) === null || _ === void 0 ? void 0 : _.key;\n  }\n  getLastKey() {\n    var _rows_;\n    let rows = [...this.rows];\n    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  constructor(opts) {\n    (0, $cAn5f$swchelperssrc_define_propertymjs)(this, \"keyMap\", new Map());\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n      for (let child of node.childNodes) {\n        if (child.type === \"cell\" && child.parentKey == null)\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n        visit(child);\n        last = child;\n      }\n      if (last) last.nextKey = null;\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child1 of prevNode.childNodes) if (!childKeys.has(child1.key)) remove(child1);\n      }\n    };\n    let remove = node => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n    let last;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: \"row-\" + i,\n        type: \"row\",\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      };\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else rowNode.prevKey = null;\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last = rowNode;\n    });\n    if (last) last.nextKey = null;\n  }\n}\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState, $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"mappings":";;;;AAAA;;;;;;;;;;ACAA;;AAuBO,SAASA,0CAA4DC,KAA6B,EAAmB;EAC1H,IAAI;IAAAC,YAACA;IAAUC,WAAEA;EAAS,CAAC,GAAGF;EAC9B,IAAIG,iBAAiB,oCAAwB,EAAEH;EAC/C,IAAII,eAAe,kBAAO,EAAC,MACvBJ,MAAMI,YAAY,GAAG,IAAIC,IAAIL,MAAMI,YAAY,IAAI,IAAIC,KAAU,EACjE,CAACL,MAAMI,YAAY,CAAC;EAExB,IAAIE,gBAAgBH,eAAeG,aAAa;EAChDH,eAAeG,aAAa,GAAG,CAACC,KAAKC,UAAU;IAC7C;IACA,IAAIN,cAAc,UAAUK,OAAO,IAAI,EAAE;MACvC,IAAIE,OAAOR,WAAWS,OAAO,CAACH;MAC9B,IAAI,kDAAMI,IAAI,MAAK,QAAQ;YAGjBC,YAEAC;QAJR,IAAIC,WAAW,IAAIL,KAAKM,UAAU,CAAC;QACnC,IAAIP,UAAU,QACZD,MAAM,sBAAQ,CAACO,SAASE,MAAM,GAAG,EAAE,cAA7BJ,4CAA+BL,GAAG,MAExCA,MAAM,uBAAQ,CAAC,EAAE,cAAXM,8CAAaN,GAAG;MAE1B;IACF;IAEAD,cAAcC,KAAKC;EACrB;EAEA,IAAIS,mBAAmB,kBAAM,EAAE,MAC7B,KAAI,0BAAe,EAAEhB,YAAYE,iBAC/B,CAACF,YAAYE,eAAe;EAGhC;EACA,MAAMe,mBAAmB,iBAAK,EAAE,IAAI;EACpC,oBAAS,EAAC,MAAM;IACd,IAAIf,eAAegB,UAAU,IAAI,IAAI,IAAI,CAAClB,WAAWS,OAAO,CAACP,eAAegB,UAAU,GAAG;MACvF,MAAMC,OAAOF,iBAAiBG,OAAO,CAACX,OAAO,CAACP,eAAegB,UAAU;MACvE,MAAMG,aACJF,KAAKG,SAAS,IAAI,IAAI,KAAKH,KAAKT,IAAI,KAAK,UAAUS,KAAKT,IAAI,KAAK,eAAeS,KAAKT,IAAI,KAAK,QAAO,IACrGO,iBAAiBG,OAAO,CAACX,OAAO,CAACU,KAAKG,SAAS,IAC/CH,IAAI;MACN,MAAMI,aAAaN,iBAAiBG,OAAO,CAACI,IAAI;MAChD,MAAMA,OAAOxB,WAAWwB,IAAI;MAC5B,MAAMC,OAAOF,WAAWR,MAAM,GAAGS,KAAKT,MAAM;MAC5C,IAAIW,QAAQC,KAAKC,GAAG,CAEhBH,OAAO,IACPE,KAAKE,GAAG,CAACR,WAAWK,KAAK,GAAGD,OAAO,GAAG,KACtCJ,WAAWK,KAAK,EAElBF,KAAKT,MAAM,GAAG;MAChB,IAAIe;MACJ,OAAOJ,SAAS,GAAG;QACjB,IAAI,CAACV,iBAAiBe,UAAU,CAACP,IAAI,CAACE,MAAM,CAACpB,GAAG,GAAG;UACjDwB,SAASN,IAAI,CAACE,MAAM;UACpB;QACF;QACA;QACA,IAAIA,QAAQF,KAAKT,MAAM,GAAG,GACxBW,aAEK;UACL,IAAIA,QAAQL,WAAWK,KAAK,EAC1BA,QAAQL,WAAWK,KAAK;UAE1BA;QACF;MACF;MACA,IAAII,QAAQ;QACV,MAAMhB,aAAagB,OAAOE,aAAa,GAAG,IAAIF,OAAOhB,UAAU,CAAC,GAAG,EAAE;QACrE,MAAMmB,aACJH,OAAOE,aAAa,IACpBX,eAAeF,QACfA,KAAKO,KAAK,GAAGZ,WAAWC,MAAM,GAC9BD,UAAU,CAACK,KAAKO,KAAK,CAAC,CAACpB,GAAG,GAC1BwB,OAAOxB,GAAG;QACZJ,eAAeG,aAAa,CAAC4B;MAC/B,OACE/B,eAAeG,aAAa,CAAC,IAAI;IAErC;IACAY,iBAAiBG,OAAO,GAAGpB;EAC7B,GAAG,CAACA,YAAYgB,kBAAkBd,gBAAgBA,eAAegB,UAAU,CAAC;EAE5E,OAAO;gBACLlB;kBACAG;IACA+B,8BAA8B,KAAK;sBACnClB;EACF;AACF;;AC/GA;;;;;;;;;;;IAsHImB,gDAAOC,QAAQ;AAjGZ,MAAMC;EAiGX,EAAEF,0CAAmB;IACnB,OAAO,IAAI,IAAI,CAACX,IAAI,CAAC;EACvB;EAEA,IAAIc,OAAO;IACT,OAAO,IAAI,IAAI,CAACd,IAAI,CAAC,CAACT,MAAM;EAC9B;EAEAwB,UAAU;IACR,OAAO,IAAI,CAACC,MAAM,CAACC,IAAI;EACzB;EAEAC,aAAapC,GAAQ,EAAE;IACrB,IAAIa,OAAO,IAAI,CAACqB,MAAM,CAACG,GAAG,CAACrC;IAC3B,OAAOa,OAAOA,KAAKyB,OAAO,GAAG,IAAI;EACnC;EAEAC,YAAYvC,GAAQ,EAAE;IACpB,IAAIa,OAAO,IAAI,CAACqB,MAAM,CAACG,GAAG,CAACrC;IAC3B,OAAOa,OAAOA,KAAK2B,OAAO,GAAG,IAAI;EACnC;EAEAC,cAAc;QACLC;IAAP,OAAO,SAAI,IAAI,CAACxB,IAAI,CAAC,CAAC,EAAE,cAAjBwB,0BAAmB1C,GAAG;EAC/B;EAEA2C,aAAa;QAEJC;IADP,IAAI1B,OAAO,IAAI,IAAI,CAACA,IAAI,CAAC;IACzB,OAAO,cAAI,CAACA,KAAKT,MAAM,GAAG,EAAE,cAArBmC,oCAAuB5C,GAAG;EACnC;EAEAG,QAAQH,GAAQ,EAAE;IAChB,OAAO,IAAI,CAACkC,MAAM,CAACG,GAAG,CAACrC;EACzB;EAEA6C,GAAGC,GAAW,EAAE;IACd,MAAMX,OAAO,IAAI,IAAI,CAACF,OAAO,GAAG;IAChC,OAAO,IAAI,CAAC9B,OAAO,CAACgC,IAAI,CAACW,IAAI;EAC/B;EAlIAC,YAAYC,IAA+B,EAAE;IAJ7C,6DAAgC,IAAIC;IAKlC,IAAI,CAACf,MAAM,GAAG,IAAIe;IAClB,IAAI,CAACC,WAAW,GAAGF,iDAAME,WAAW;IACpC,IAAI,CAAChC,IAAI,GAAG,EAAE;IAEd,IAAIiC,QAAStC,QAAsB;MACjC;MACA;MACA;MACA,IAAIuC,WAAW,IAAI,CAAClB,MAAM,CAACG,GAAG,CAACxB,KAAKb,GAAG;MACvC,IAAIgD,KAAKK,SAAS,EAChBxC,OAAOmC,KAAKK,SAAS,CAACxC;MAGxB,IAAI,CAACqB,MAAM,CAACoB,GAAG,CAACzC,KAAKb,GAAG,EAAEa;MAE1B,IAAI0C,YAAY,IAAIzD;MACpB,IAAI0D;MACJ,KAAK,IAAIvD,SAASY,KAAKL,UAAU,EAAE;QACjC,IAAIP,MAAMG,IAAI,KAAK,UAAUH,MAAMe,SAAS,IAAI,IAAI;UAClD;UACAf,MAAMe,SAAS,GAAGH,KAAKb,GAAG;QAE5BuD,UAAUE,GAAG,CAACxD,MAAMD,GAAG;QAEvB,IAAIwD,MAAM;UACRA,KAAKhB,OAAO,GAAGvC,MAAMD,GAAG;UACxBC,MAAMqC,OAAO,GAAGkB,KAAKxD,GAAG;QAC1B,OACEC,MAAMqC,OAAO,GAAG,IAAI;QAGtBa,MAAMlD;QACNuD,OAAOvD;MACT;MAEA,IAAIuD,MACFA,KAAKhB,OAAO,GAAG,IAAI;MAGrB;MACA,IAAIY,UAAU;QACZ,KAAK,IAAIM,UAASN,SAAS5C,UAAU,EACnC,IAAI,CAAC+C,UAAUI,GAAG,CAACD,OAAM1D,GAAG,GAC1B4D,OAAOF;MAGb;IACF;IAEA,IAAIE,SAAU/C,QAAsB;MAClC,IAAI,CAACqB,MAAM,CAAC2B,MAAM,CAAChD,KAAKb,GAAG;MAC3B,KAAK,IAAIC,SAASY,KAAKL,UAAU,EAC/B,IAAI,IAAI,CAAC0B,MAAM,CAACG,GAAG,CAACpC,MAAMD,GAAG,MAAMC,OACjC2D,OAAO3D;IAGb;IAEA,IAAIuD;IACJR,KAAKc,KAAK,CAACC,OAAO,CAAC,CAAClD,MAAMmD,MAAM;MAC9B,IAAIC,UAAU;QACZC,OAAO;QACPlE,KAAK,SAASgE;QACd5D,MAAM;QACN+D,OAAOC;QACP1C,eAAe,IAAI;QACnBlB,YAAY,IAAIK,KAAKL,UAAU,CAAC;QAChC6D,UAAUD;QACVE,WAAWF;QACX,GAAGvD,IAAI;QACPO,OAAO4C;MACT;MAEA,IAAIR,MAAM;QACRA,KAAKhB,OAAO,GAAGyB,QAAQjE,GAAG;QAC1BiE,QAAQ3B,OAAO,GAAGkB,KAAKxD,GAAG;MAC5B,OACEiE,QAAQ3B,OAAO,GAAG,IAAI;MAGxB,IAAI,CAACpB,IAAI,CAACqD,IAAI,CAACN;MACfd,MAAMc;MAENT,OAAOS;IACT;IAEA,IAAIT,MACFA,KAAKhB,OAAO,GAAG,IAAI;EAEvB;AAyCF","names":["$62967d126f3aa823$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","disabledKeys","Set","setFocusedKey","key","child","item","getItem","type","_children_","_children_1","children","childNodes","length","selectionManager","cachedCollection","focusedKey","node","current","parentNode","parentKey","cachedRows","rows","diff","index","Math","min","max","newRow","isDisabled","hasChildNodes","keyToFocus","isKeyboardNavigationDisabled","$16805b1b18093c5f$var$_Symbol_iterator","iterator","$16805b1b18093c5f$export$de3fdf6493c353d","size","getKeys","keyMap","keys","getKeyBefore","get","prevKey","getKeyAfter","nextKey","getFirstKey","_","getLastKey","_rows_","at","idx","constructor","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","last","add","child1","has","remove","delete","items","forEach","i","rowNode","level","value","undefined","rendered","textValue","push"],"sources":["packages/@react-stately/grid/src/index.ts","packages/@react-stately/grid/src/useGridState.ts","packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useGridState} from './useGridState';\nexport {GridCollection} from './GridCollection';\n\nexport type {GridStateOptions, GridState} from './useGridState';\n","import {GridCollection, GridNode} from '@react-types/grid';\nimport {Key, useEffect, useMemo, useRef} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = [...item.childNodes];\n        if (child === 'last') {\n          key = children[children.length - 1]?.key;\n        } else {\n          key = children[0]?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode =\n        node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ?\n        cachedCollection.current.getItem(node.parentKey) :\n        node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(parentNode.index - diff + 1, 0) :\n          parentNode.index\n        ),\n        rows.length - 1);\n      let newRow:GridNode<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key)) {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled row.\n        } else {\n          if (index > parentNode.index) {\n            index = parentNode.index;\n          }\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...newRow.childNodes] : [];\n        const keyToFocus =\n          newRow.hasChildNodes &&\n          parentNode !== node &&\n          node.index < childNodes.length ?\n          childNodes[node.index].key :\n          newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else {\n        selectionState.setFocusedKey(null);\n      }\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}